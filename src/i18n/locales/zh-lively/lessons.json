{
  "categories": {
    "chapter1": "第 1 章：模式入门与基础移动",
    "chapter2": "第 2 章：单词导航与小幅编辑",
    "chapter3": "第 3 章：操作框架与高级编辑",
    "chapter4": "第 4 章：行内查找与精准删改",
    "chapter5": "第 5 章：文本对象与语义编辑",
    "chapter6": "第 6 章：搜索跳转与批量重构"
  },
  "lessons": {
    "modes-basics": {
      "title": "模式：Normal/Insert 入门",
      "shortDescription": "用故事和节奏感，带你搞懂 Vim 为何要有“模式”。",
      "content": {
        "0": "## Normal vs Insert：Vim 的两种人格\n\n很多人第一次打开 Vim，都会经历同一个惊吓瞬间：\n\n> “我在键盘上狂敲，为什么屏幕一个字都没出来？！”\n\n别慌，不是电脑坏了，是 Vim 在说：**“等等，现在是 Normal 模式，我在等你发指令。”**\n\n在 Vim 里，你可以把自己想象成“队长”，而编辑器是“执行队”。\n\n- **Normal 模式**：你不直接敲字，而是像队长一样发指令：\n  - 往上/下/左/右移动光标，\n  - 删掉一段，\n  - 复制一块，\n  - 跳到别的地方。\n- **Insert 模式**：才是你熟悉的“打字模式”，想写什么就写什么。\n- 随时按 **Esc**，队伍立刻回到 **Normal**，停止输入，准备下一条指令。\n\n真正高效的 Vim 使用者，几乎一直待在 Normal，只在需要改东西的那一小会儿，才短暂切进 Insert。你不需要一口气变成那样，但可以从一个简单节奏开始：\n\n1. 在 **Normal** 里先移动到“要改的地方”。\n2. 进 **Insert**，快速完成这一小段修改。\n3. 按 **Esc** 回到 **Normal**，继续下一步。\n\n记住一句话就好：**先动，再改。**",
        "1": "## 四种进入 Insert 的方式（顺便背下助记）\n\n接下来我们来认识几位“出场率最高”的角色——它们都是从 Normal 切到 Insert 的入口：\n\n- **i** – 在光标前插入。\n- **a** – 在光标后插入。\n- **o** – 在当前行下方新开一行并插入。\n- **O** – 在当前行上方新开一行并插入。\n- **Esc** – 离开 Insert，回到 Normal，收工。\n\n这些键名并不是随便选的，它们背后都连着一个英文单词，顺手一记，后面会非常好用：\n\n- `i` → 插入 (**Insert**)：在光标前插入内容；\n- `a` → 追加 (**Append**)：在光标后继续往后写；\n- `o` → 向下打开一行 (**open below**)：在下面“撕”一行出来写；\n- `O` → 向上打开一行 (**Open above**)：在上面新开一行。\n\n你现在不必把它们倒背如流，只要知道：\n\n> “我想在这里开始打字了” → 按其中一个键进 Insert；\n> “我打完了，先别乱动” → 按 **Esc** 回 Normal。\n\n后面的课程会不断用到这些键，你会在练习里自然把它们变成肌肉记忆。",
        "2": "## 示例：在 Normal 和 Insert 间来回切换\n\n在一小段代码上：用 `i` 进 Insert 随手输入，Esc 回 Normal；再用 `$` 到行尾，按 `a` 进 Insert 补注释，感受“打完就跑，随时刹车”的节奏。",
        "3": {
          "tracks": {
            "0": "Insert 与 Normal：第一次切换体验"
          },
          "steps": {
            "0": "i：在“int”前进入 Insert，好像把光标变成一个打字光标。",
            "1": "输入“/”——注意代码在 Insert 中是实时变化的。",
            "2": "Escape：一键回到 Normal，输入瞬间“刹车”。",
            "3": "$：在 Normal 里跳到行尾，用移动命令定位目标。",
            "4": "a：在分号后进入 Insert，相当于在后面“接着写”。",
            "5": "输入“/”开始在末尾添加注释。",
            "6": "Escape：再次回到 Normal，准备下一步行动。"
          }
        },
        "4": {
          "keys": {
            "0": "返回 Normal 模式（随时“刹车”）",
            "1": "在光标前插入（Insert）",
            "2": "在光标后插入（Append）",
            "3": "在下方新建一行并插入（open below）",
            "4": "在上方新建一行并插入（Open above）"
          }
        },
        "5": {
          "goals": {
            "add-vim-word": "在第一行的注释中优雅地加入 “Vim” 一词，让读者一眼就知道这节课在讲什么。",
            "add-todo-comment": "再加一行 TODO 注释，比如 \"// TODO: log the message\"，就像真实项目里给自己留一个小备忘。",
            "add-done-log": "再写一条 log，打印 \"done\"，让这个小程序真正“说句话”告诉你它跑完了。"
          }
        }
      }
    },
    "motions-hjkl": {
      "title": "用 HJKL 移动：留在主键区",
      "shortDescription": "把 HJKL 变成“迷你方向键”，从此减少去角落摸箭头键的次数。",
      "content": {
        "0": "## 为什么是 HJKL？让手别再跑去角落\n\n想象一个常见画面：你正在写代码，光标在文件中间，结果手习惯性伸到键盘右下角，去找那四个方向键。\n\n时间一长你会发现：\n\n- 视线在屏幕上，\n- 右手在键盘右下角，\n- 左手在键盘左侧，\n\n整个人像被扭成一只“写代码的螃蟹”。\n\nVim 的思路很直接：**既然我们大部分时间在“动光标”，那就把移动键放在最舒服的主键区。**\n\n于是有了这四个键：\n\n- **h** → 左（左边那一排的最左）；\n- **j** → 下（j 键长得像一条往下的竖线）；\n- **k** → 上（在 j 上面，负责向上）；\n- **l** → 右（右手食指常驻的位置）。\n\n你可以把光标想象成网格上的一个小人：\n\n> 你的任务：只用 **h/j/k/l** 把这个小人“走”到目标位置。\n\n一开始可能会有点别扭，但一旦习惯了，你会惊讶于：\n\n- 手几乎不用离开主键区，\n- 视线不用离开代码，\n- 光标却可以在文件里飞来飞去。",
        "1": {
          "tracks": {
            "0": "用 HJKL 走一小段“迷你地图”"
          },
          "steps": {
            "0": "j：从函数头往下走，来到变量那一行。",
            "1": "k：再回到函数头，确认你已经掌控“上”和“下”。",
            "2": "j：再一次向下，巩固一下对 j 的感觉。",
            "3": "l：向右移动一格，尝试“横向挪步”。",
            "4": "l：再向右一格，习惯光标一点点向右滑动的感觉。",
            "5": "h：往左退回一格，告诉自己——走错了也可以随时撤一步。"
          }
        },
        "2": "## 示例：用 HJKL 逛一小块地图\n\n从函数头走到变量行再走回来，全程只按 **h j k l**，手不离主键区，像在网格上“走格子”。",
        "3": {
          "keys": {
            "0": "向左移动一格（h）",
            "1": "向下移动一行（j）",
            "2": "向上移动一行（k）",
            "3": "向右移动一格（l）"
          }
        },
        "4": {
          "goals": {
            "reach-X": "只用 HJKL，把光标移动到第二行的 X 上——就当是在小地图上走到“宝箱”位置。",
            "reach-TARGET": "再把光标移动到最后一行单词 “TARGET” 里的字母 T 上，作为这一关的终点旗帜。"
          }
        }
      }
    },
    "motions-line-bounds": {
      "title": "行边界：0,^,$ 快速落点",
      "shortDescription": "学会三种“瞬移”：行首、代码起点、行尾，再配合微调移动。",
      "content": {
        "0": "## 一行里的三个“黄金落点”\n\n写代码的时候，你会发现自己频繁想去的，其实就是这一行里的**几个固定位置**：\n\n- 行最开头：看缩进、加/删前缀；\n- 这一行真正开始写代码的地方（缩进之后的第一个非空字符）；\n- 行尾：补分号、加注释、收尾。\n\nVim 很干脆地给出了三个专门的动作（motion）：\n\n- **0** → 跳到列 0，也就是这一行最左边的开头；\n- **^** → 跳到第一个非空字符（跳过缩进）；\n- **$** → 跳到行尾（最后一个字符）。\n\n你可以先用这三个键“粗定位”，然后再用 **h/l** 做一点点微调：\n\n> 先用 0 / ^ / $ 把自己瞬移到大致位置，\n> 再用 h / l 像拿镊子一样精确挪动。",
        "1": {
          "tracks": {
            "0": "行边界跳转小练习"
          },
          "steps": {
            "0": "0：从中间瞬移到列 0，感受一下“绝对行首”的位置。",
            "1": "^：从行首跳到第一个非空字符 “s”，相当于“一步跨过缩进”。",
            "2": "$：再跳到行尾（分号之后），为补注释和分号做好准备。"
          }
        },
        "2": "## 示例：一键跳到三个关键点\n\n在一行声明上，先 **0** 回列 0，再 **^** 到第一个代码字符，最后 **$** 跳到行尾，熟悉三种落点的瞬移感。",
        "3": {
          "keys": {
            "0": "跳到当前行的列 0（绝对行首）",
            "1": "跳到首个非空字符（代码真正开始处）",
            "2": "跳到当前行的行尾",
            "3": "向左微调（配合 0/^/$ 使用）",
            "4": "向右微调（配合 0/^/$ 使用）"
          }
        },
        "4": {
          "goals": {
            "go-to-absolute-start": "把光标移到第二行的列 0，确认你能随时回到“绝对行首”。",
            "go-to-first-code-char": "把光标移到第二行首个非空字符上，也就是代码真正开始的地方。",
            "go-to-line-end": "把光标移到第二行最后一个字符上，为在行尾补东西做好准备。"
          }
        }
      }
    },
    "modes-movement-mini-review": {
      "title": "本章回顾：先移动再插入",
      "shortDescription": "把 HJKL、行边界和 Insert 出入口串成一条完整“编辑节奏”。",
      "content": {
        "0": "## Normal → Insert：真正写代码时的节奏长什么样？\n\n走到这里，你已经学会了：\n\n- 用 **h j k l** 像在小地图里走路一样移动光标；\n- 用 **0, ^, $** 一键瞬移到行首、代码起点和行尾；\n- 用 **i, a, o, O** 从 Normal 切到 Insert，再用 **Esc** 回来。\n\n这些命令单独看都不难，但真正写代码时，它们会组合成一个非常自然的节奏：\n\n1. 在 **Normal** 中用各种移动命令，把光标放到“需要修改”的位置附近；\n2. 用 **i / a / o / O** 进入 **Insert**，只专注做这一次小修改；\n3. 按 **Esc** 回到 **Normal**，准备下一个操作。\n\n你可以把它理解成：\n\n> Normal：规划路线 + 下达指令；\n> Insert：短暂进入“施工现场”；\n> Esc：完工，退出现场，继续规划下一步。\n\n这一节我们会用一个小程序，带你把这一整套节奏完整走一遍，让它从“概念”变成“感觉”。",
        "1": "## 示例：在 add(10, 20, 30) 里做微手术\n\n围绕 add(10, 20, 30)，先用 **dt,** 剪掉开头的 `10,`，再走到末尾用 **ct)** 把剩余参数改成单个 `42`，结构不乱、动作很快。",
        "2": {
          "tracks": {
            "0": "移动 + 插入：修一段小程序"
          },
          "steps": {
            "0": "O：在当前行上方打开一行并进入 Insert，就像在上面插入一条说明。",
            "1": "输入“/”开始写注释，让这段代码更有上下文。",
            "2": "再输入“/”，组成标准的“//”。",
            "3": "Escape：在新注释行上回到 Normal，切回“指挥官”视角。",
            "4": "j：移动到 std::cout 那行，为这条输出加点“活力”。",
            "5": "$：跳到行尾，准备在语句末尾做修改。",
            "6": "a：在分号后进入 Insert，相当于在这一行后面补一句话。",
            "7": "输入“!”让问候更有语气一点。",
            "8": "Escape：回到 Normal，确认刚才的修改已经“落地”。",
            "9": "o：在下方新开一行并进入 Insert，好像在结果下方再记一笔。",
            "10": "输入“/”开始另外一条注释。",
            "11": "再输入“/”，构成“//”。",
            "12": "输入空格，让注释读起来更自然。",
            "13": "输入“d”。",
            "14": "输入“o”。",
            "15": "输入“n”。",
            "16": "输入“e”，完成“// done”，给程序一个“任务完成”的标记。",
            "17": "Escape：退出 Insert，留下整洁的代码和有用的注释。"
          }
        },
        "3": {
          "keys": {
            "0": "向左移动（h）",
            "1": "向下移动（j）",
            "2": "向上移动（k）",
            "3": "向右移动（l）",
            "4": "跳到当前行列 0（0）",
            "5": "跳到首个非空字符（^）",
            "6": "跳到当前行行尾（$）",
            "7": "在光标前插入（i）",
            "8": "在光标后插入（a）",
            "9": "在下方新建一行并插入（o）",
            "10": "在上方新建一行并插入（O）",
            "11": "返回 Normal 模式（Esc）"
          }
        },
        "4": {
          "goals": {
            "add-semicolon-message": "在定义 \"message\" 的那一行末尾加上分号，让语句变得完整、规范。",
            "add-semicolon-log": "在 console.log 那行的末尾也补上分号，顺便养成一致的代码风格习惯。",
            "add-todo-comment": "加一行 TODO 注释，比如 \"// TODO: print greeting\"，像真实项目一样给自己留个“以后要改进”的小标记。"
          }
        }
      }
    },
    "motions-words": {
      "title": "按单词移动：w,b,e 提速",
      "shortDescription": "从“一格一格挪”升级为“按词跳跃”，让光标移动速度直接起飞。",
      "content": {
        "0": "## 为什么要按“单词”移动？\n\n如果只靠 **h** / **l** 一格一格挪，很快你就会有一种感觉：\n\n> “我不是在写代码，我是在数格子。”\n\n在真实项目里，光标常常需要跨过一整块变量名、类型名、函数名，而不是老老实实从每一个字符踩过去。\n\nVim 给你的一套“更大步伐”就是 **word motions**：\n\n- **w** – 跳到**下一个单词的开头**；\n- **b** – **后退**到前一个单词的开头；\n- **e** – 跳到**当前/下一个单词的结尾**。\n\n这里的“单词 (word)”有一个简单但很有用的定义：\n\n> 一连串字母/数字/下划线，被空格或标点隔开，就是一个 word。\n\n用人话讲就是：把代码里那些“变量名”“函数名”“类型名”当作一个整体来走路，而不是一笔一划去数。这样一来：\n\n- 定位变量时可以“几步”就跳到位；\n- 修名字时只需 w/b/e 配合 Insert 就够了。",
        "1": "## 示例：按词跳格子\n\n从行首一路用 **w/e/b** 在变量名间跳跃，比一格格挪动更像“瞬移”。",
        "2": {
          "tracks": {
            "0": "按词移动小练习"
          },
          "steps": {
            "0": "w：从缩进跳到 \"std::string\"，一下跨过前面的空白。",
            "1": "w：再跳到 \"fullName\" 的开头。",
            "2": "e：跳到 \"fullName\" 的末尾，方便在后面继续编辑。",
            "3": "b：退回到 \"fullName\" 开头，体会前后移动的配合。"
          }
        },
        "3": {
          "keys": {
            "0": "跳到下一个单词开头（w）",
            "1": "跳回上一个单词开头（b）",
            "2": "跳到当前/下一个单词结尾（e）"
          }
        },
        "4": {
          "goals": {
            "reach-lastName-start": "把光标移到第二行单词 \"lastName\" 的开头，就像在代码里精准点名。",
            "reach-firstName-end": "把光标移到第三行单词 \"firstName\" 的结尾，为后面拼接 fullName 做好准备。"
          }
        }
      }
    },
    "words-fix-small-things": {
      "title": "按词移动修小错",
      "shortDescription": "把 w/b/e 和 i/a 串起来，用一套节奏专门修小拼写错误。",
      "content": {
        "0": "## 先移动，再插入：不要一边走路一边打字\n\n在普通编辑器里，我们很容易一边按方向键、一边删字符、一边改名字——结果是走走停停、效率很低。\n\nVim 更推荐的节奏是分两步走：\n\n1. 在 **Normal** 模式，用 **w / b / e** 把光标精确落到“问题单词”附近；\n2. 再用 **i**（在前插入）或 **a**（在后插入）切到 **Insert**，专心修这一处；\n3. 需要删旧字母就用 Backspace，直接打出新内容；\n4. 修完按 **Esc** 回到 Normal，继续找下一个问题。\n\n也就是说：\n\n> Normal 用来“搜目标”，Insert 用来“动刀”，两件事拆开干。\n\n这样不但手感更清晰，也更不容易在半路“走丢光标”或删错地方。",
        "1": "## 示例：先找准，再补刀\n\n用 **w/e** 把光标停在单词末尾，`a` 进 Insert 补上缺字母，完整走一遍“先移动、再修改”的节奏。",
        "2": {
          "tracks": {
            "0": "按词 + 插入：修一个变量名"
          },
          "steps": {
            "0": "w：跳到 \"int\"，确认按词移动的起点。",
            "1": "w：跳到 \"count\"，锁定要修改的单词。",
            "2": "e：跳到 \"count\" 的末尾，准备在后面补字母。",
            "3": "a：在 \"count\" 后进入 Insert，就地开始修改。",
            "4": "输入 “e” 开始补 \"er\"。",
            "5": "输入 “r”，得到新名字 \"counter\"。",
            "6": "Escape：回到 Normal，检查变量名已经修正。"
          }
        },
        "3": {
          "keys": {
            "0": "下一个单词开头（w）",
            "1": "上一个单词开头（b）",
            "2": "单词结尾（e）",
            "3": "在光标前插入（i）",
            "4": "在光标后插入（a）",
            "5": "回到 Normal 模式（Esc）"
          }
        },
        "4": {
          "goals": {
            "fix-username": "把所有写错的 \"userNmae\" 改成 \"userName\"，就像给变量统一改名牌。",
            "fix-isactive": "把所有 \"isActve\" 修成 \"isActive\"，避免以后踩到这种小拼写坑。"
          }
        }
      }
    },
    "motions-WORDs": {
      "title": "按 WORD 移动：跨越整块代码",
      "shortDescription": "在符号很多的代码里，用 WORD 把“空格之间的一整坨”当作一个大步跨过去。",
      "content": {
        "0": "## word vs WORD：小步走字，还是大步跨块\n\n前一节我们说的 **w/b/e**，按的是“单词 (word)”的节奏：\n\n- 字母、数字、下划线连在一起算一个 word；\n- 遇到标点、空格就会停下来。\n\n这在普通代码里已经很好用了。但当你面对一行“充满括号和逗号”的代码时，比如：\n\n```js\nt = Math.max(i, 4200), Math.min(j, 4900);\n```\n\n用小写 **w** 的效果是：\n\n- 在 `Math` 里停一下，\n- 在 `.` 前后停一下，\n- 在 `max`、`(`、`i`、`,`、`4200` 之间到处“刹车”。\n\n这时候就轮到大写的 **WORD 动作** 出场了：它把“空格之间的一整块”当作一个 **WORD**：\n\n- **W** – 下一个 WORD 的开头；\n- **B** – 上一个 WORD 的开头；\n- **E** – WORD 的结尾。\n\n你可以记成：**word 盯字符，WORD 看整块**。在符号密集的代码里，WORD 可以帮你用很少的按键跨过一长串“花里胡哨”的部分。",
        "1": "## 示例：word 小步 vs WORD 大步\n\n在符号密集的长行里，让 `w` 和 `W` 赛跑：一个处处踩刹车，一个空格为界大步流星。",
        "2": {
          "0": "## 示例：两个光标赛跑\n\n用一行符号密集的代码，看看 **w**（小写）和 **W**（大写）谁跑得快：\n\n- **蓝色光标** 用 `w`，遇到标点就停。\n- **绿色光标** 用 `W`，把空格之间当成整块猛冲。\n\n数一数谁先到行尾、中途停了几次。"
        },
        "3": {
          "tracks": {
            "0": "使用 w（word）",
            "1": "使用 W（WORD）"
          },
          "steps": {
            "0": "w：从 \"auto\" 到 \"result\"，小步向前。",
            "1": "W：从 \"auto\" 到 \"result\"，一次跨过前面的部分。",
            "2": "w：从 \"result\" 到 \"=\"，在符号前停下。",
            "3": "W：把 \"= std::max(x, 42)\" 当作一整块跳过。",
            "4": "w：进入 \"std::max(x, 42)\" 的内部，继续细分。",
            "5": "w：再用几个小步跨过内部的片段。",
            "6": "W：再跳过 \"+ std::min(y, 7);\"，一脚到达末尾附近。"
          }
        },
        "4": {
          "0": "注意：**W** 只用几次跳跃就能到达行尾，而 **w** 需要更多细碎的步伐。\n\n当一行里充满括号、逗号和函数调用时，优先考虑用 WORD 来“飞越杂草丛生的区域”，再用 word 做局部微调。"
        },
        "5": {
          "keys": {
            "0": "下一个单词开头（小 word：w）",
            "1": "下一个 WORD 开头（大块：W）",
            "2": "上一个 WORD 开头（B）",
            "3": "WORD 结尾（E）"
          }
        },
        "6": {
          "goals": {
            "reach-first-math": "把光标移到第一个 \"Math\" 的 M 上，体会用 word/WORD 靠近目标的差异。",
            "reach-second-math": "把光标移到第二个 \"Math\" 的 M 上，在长行代码中快速锁定你要看的函数。"
          }
        }
      }
    },
    "small-edits-chars": {
      "title": "小编辑：x,s,r 小手术刀",
      "shortDescription": "一次只改一个字符，却不用长时间停在 Insert 模式里。",
      "content": {
        "0": "## 三个微调工具：该动“刀”的时候别拿“锯子”\n\n很多时候，你并不需要大改，只是：\n\n- 把 `==` 改成 `===`；\n- 把单词里的一个字母修一下；\n- 删掉多余的一个符号。\n\n如果每次都进 Insert，删半天再退出来，其实有点“大材小用”。\n\n在 **Normal** 模式下，Vim 提供了三把专门做“微手术”的小刀：\n\n- **x** – 删除光标下的这个字符；\n- **s** – 删除光标下字符并进入 Insert，从这个位置重新打；\n- **r{char}** – 用你接下来敲的 `{char}` 直接“覆盖”掉当前字符，人还留在 Normal。\n\n可以简单记成：\n\n- `x`：这里这个字符不要了；\n- `s`：这个字符不行，我要在原地重新打一个；\n- `r`：这个位置只换成另一个字符，其他都别动。\n\n一旦习惯，你会发现很多小问题可以用一两下键解决，而不是开一整段“插入会话”。",
        "1": "## 示例：三把小手术刀连用\n\n连续用 **x** 删数字、**r** 原地换字符、**s** 删改一个字母，全部在 Normal 下快速收工。",
        "2": {
          "tracks": {
            "0": "小编辑：x、r、s 连续上手"
          },
          "steps": {
            "0": "w：跳到 \"int\"，作为起点。",
            "1": "w：跳到 \"value\"。",
            "2": "w：跳到 \"10\"。",
            "3": "x：删掉“0”，让值从 10 变成 1。",
            "4": "j：移动到 \"count\" 行，准备改第二处。",
            "5": "w：跳到 \"int\"。",
            "6": "w：跳到 \"count\"。",
            "7": "w：跳到数字 “0”。",
            "8": "r：准备替换当前数字。",
            "9": "输入 “1”，赋值变为 count = 1。",
            "10": "j：移动到字符串那一行。",
            "11": "w：跳到 \"std::string\"。",
            "12": "w：跳到 \"text\"。",
            "13": "w：跳到字符串 \"Hxllo\"。",
            "14": "l：移到错误的字母 “x”。",
            "15": "s：删除 “x” 并在原位进入 Insert。",
            "16": "输入 “e”，把单词修成 \"Hello\"。",
            "17": "Escape：小改完成，回到 Normal。"
          }
        },
        "3": {
          "keys": {
            "0": "删除光标下字符（x）",
            "1": "删除光标下字符并进入 Insert（s）",
            "2": "用下一个键替换光标下字符（r{char}）",
            "3": "回到 Normal 模式（Esc）"
          }
        },
        "4": {
          "goals": {
            "make-strict-equals": "把 if 条件里的 \"==\" 改成 \"===\"，体验一下只改一个字符带来的语义变化。",
            "fix-zerro": "把字符串改成 \"Zero\"，修掉那个多余的 r。"
          }
        }
      }
    },
    "words-mini-review": {
      "title": "本章回顾：按词移动与小编辑",
      "shortDescription": "把 word/WORD、x/s/r 和 i/a 组合起来，清理一小段“真实风格”的代码。",
      "content": {
        "0": "## 汇总：从“挪光标”升级到“修一段代码”\n\n这一章里，你已经收集了一整套和“按词移动 + 小编辑”相关的能力：\n\n- 用 **w, b, e** 按 word 移动，跳过一个个单词；\n- 用 **W, B, E** 按 WORD 跨越空格之间的一整块；\n- 用 **x, s, r** 做单字符级别的小手术；\n- 用 **i/a** 短暂进入 Insert，**Esc** 再回来 Normal。\n\n单独看，它们只是一些分散的命令；\n\n连在一起，就变成了一套可以在真实代码里反复使用的“清理组合拳”：\n\n1. 用 word/WORD 把光标快速带到“可疑区域”；\n2. 用 x/s/r 解决那些单字符、小拼写的问题；\n3. 必要时用 i/a 进入 Insert，稍微多改几个字符；\n4. 改完马上 Esc，继续在 Normal 里巡视下一处。\n\n这一节作为本章回顾，你可以在一小段代码上自由组合这些招式，体会一下：\n\n> 从“我知道这些命令”到“我能用它们把代码整理干净”，中间只差几轮练习。",
        "1": "## 示例：h/l vs w vs W\n\n三个光标分别用 h/l、w、W 前进，对比单字符、小词、大块的速度差异。",
        "2": {
          "tracks": {
            "0": "使用 h/l 逐字符移动",
            "1": "使用 w（word）跨词移动",
            "2": "使用 W（WORD）跨块移动"
          },
          "steps": {
            "0": "h/l 光标：向右移动一个字符。",
            "1": "h/l 光标：再向右移动。",
            "2": "h/l 光标：继续向右，一直在 \"std::vector<int>\" 里慢慢挪。",
            "3": "h/l 光标：仍在逐字符穿过 \"std::vector<int>\"。",
            "4": "w 光标：一下跳到 \"values\"。",
            "5": "w 光标：再跳到 \"=\"。",
            "6": "W 光标：把 \"std::vector<int>\" 当作一块跳过，不再在里面逐字符走。",
            "7": "W 光标：一步跳到 \"{1,\"，直接来到初始化列表开头。"
          }
        },
        "3": {
          "keys": {
            "0": "下一个单词开头（w）",
            "1": "上一个单词开头（b）",
            "2": "单词结尾（e）",
            "3": "下一个 WORD 开头（W）",
            "4": "上一个 WORD 开头（B）",
            "5": "WORD 结尾（E）",
            "6": "删除字符（x）",
            "7": "替换单字符并插入（s）",
            "8": "替换字符（r）",
            "9": "光标前插入（i）",
            "10": "光标后插入（a）",
            "11": "在下方新建一行并插入（o）",
            "12": "回到 Normal（Esc）"
          }
        },
        "4": {
          "goals": {
            "fix-curentCount": "把所有拼错的 \"curentCount\" 改成 \"currentCount\"，让变量名更专业。",
            "strict-equals-again": "把 if 条件中的 \"==\" 改成 \"===\"，再次巩固严格比较的修法。",
            "add-todo-comment-review": "添加一行 TODO 注释，如 \"// TODO: check other counters\"，模拟真实项目里的“以后要检查”标记。"
          }
        }
      }
    },
    "operator-delete-basic": {
      "title": "用 d+动作删除：一句话删东西",
      "shortDescription": "学会把“想删哪一段”翻译成 d + motion 这种小句子。",
      "content": {
        "0": "## 操作符 + 动作：动词 + 范围\n\n到目前为止，你已经会用 **w**、**0**、**$** 之类的动作 (motion) 在文本里走来走去。\n\n现在要加上第二块积木：**操作符 (operator)**。可以把它理解成句子里的“动词”，告诉 Vim：\n\n> 我要对接下来那一段“做什么事”。\n\n这一节我们先看最常见的一个：\n\n- **d** 代表“删除 (delete)”。\n\n当你把操作符和动作拼在一起，就得到了一个完整的小句子：\n\n- `d` + `w` → “从这里删到下一个单词开头”；\n- `d` + `0` → “从这里删回行首”；\n- `d` + `$` → “从这里删到行尾”。\n\n你可以真的在脑子里这么读它们：\n\n- `dw` → “向前删一个词”；\n- `d0` → “删到本行行首”；\n- `d$` → “删到本行行尾”。\n\n只要你能说出“我要删到哪儿”，基本上都能翻译成 `d + 某个 motion`。",
        "1": "## 示例：d+动作删词与删行尾\n\n先用 `dw` 删除变量名，再用 `d$` 一把删掉行尾注释，体会删除操作符跟随 motion。",
        "2": {
          "tracks": {
            "0": "d + 动作删除：从单词到行尾"
          },
          "steps": {
            "0": "w：跳到 \"debugValue\"，锁定要处理的单词。",
            "1": "d：开始删除操作符。",
            "2": "w：dw —— 删除整个单词 \"debugValue\"。",
            "3": "w：移动到注释起点 \"//\"。",
            "4": "d：再次开始删除。",
            "5": "$：d$ —— 从这里删到行尾，把整条注释一并移除。"
          }
        },
        "3": {
          "keys": {
            "0": "删除操作符（与动作组合：d{motion}）",
            "1": "跳到下一个单词开头（w）",
            "2": "跳到列 0（0）",
            "3": "跳到首个非空字符（^）",
            "4": "跳到行尾（$）"
          }
        },
        "4": {
          "goals": {
            "remove-debug-word": "删除 value 行注释里的 \"debug\" 一词，就像把多余标签撕掉。",
            "remove-unused-comment": "删除 count 行的整个 \"// unused\" 注释，清理掉已经无用的信息。"
          }
        }
      }
    },
    "operator-change-basic": {
      "title": "用 c+动作修改：删完立刻插入",
      "shortDescription": "把“删掉这一段并开始输入”合成一个动作：c{motion}。",
      "content": {
        "0": "## Change = 删除 + 插入\n\n`d{motion}` 只负责“删掉”某个范围，然后你还得自己手动进入 Insert 才能打新的内容。\n\n**c 操作符 (change)** 在这个基础上多做了一步：\n\n- **d{motion}** – 删除范围，并留在 Normal；\n- **c{motion}** – 删除范围，并在原地进入 **Insert**。\n\n常见的几种：\n\n- `cw` – 修改光标所在/之后的单词；\n- `c$` – 修改到行尾；\n- `c0` – 修改到列 0（把行前半段整个重写）。\n\n你可以把 `c` 想成“我要把这一段重写一遍”，而不是只有“删掉”那么简单——删完之后，光标会立刻帮你站在一个适合打字的地方。",
        "1": "## 示例：用 cw 重命名\n\n在变量上按 `cw` 删除并进入 Insert，一口气打出新名字，展示 change 的“删完即输入”。",
        "2": {
          "tracks": {
            "0": "c + 动作修改：重命名一个变量"
          },
          "steps": {
            "0": "c：在 \"userCount\" 上开始 change 操作。",
            "1": "w：cw – 删掉 \"userCount\" 并进入 Insert。",
            "2": "输入 “t”。",
            "3": "输入 “o”。",
            "4": "输入 “t”。",
            "5": "输入 “a”。",
            "6": "输入 “l”。",
            "7": "输入 “U”。",
            "8": "输入 “s”，得到 \"totalUs\"。",
            "9": "输入 “e”。",
            "10": "输入 “r”，得到 \"totalUser\"。",
            "11": "输入 “s”，变成 \"totalUsers\"。",
            "12": "Escape：带着新名字回到 Normal。"
          }
        },
        "3": {
          "keys": {
            "0": "修改操作符（删除范围并进入 Insert：c{motion}）",
            "1": "配合 c 修改单词（cw）",
            "2": "配合 c 修改到列 0（c0）",
            "3": "配合 c 修改到行尾（c$）",
            "4": "退出 Insert 模式（Esc）"
          }
        },
        "4": {
          "goals": {
            "rename-userCount": "把 main 里的 \"userCount\" 全部改名为 \"totalUsers\"，体会用 c + motion 做“重写”有多顺手。"
          }
        }
      }
    },
    "operator-yank-basic": {
      "title": "复制粘贴：y+动作 和 p/P",
      "shortDescription": "用 y{motion} 复制任意范围，再用 p/P 粘贴到你想要的位置。",
      "content": {
        "0": "## Yank：Vim 语言里的“复制”\n\n在 Vim 里，“复制”这个动作叫 **yank**，对应的操作符是 **y**。\n\n和 `d`、`c` 一样，`y` 也要配合动作 (motion)：\n\n- **y{motion}** – 复制动作范围；\n- **yy** – 复制整行；\n- **p** – 在光标**之后**粘贴（行模式下是在下一行）；\n- **P** – 在光标**之前**粘贴（行模式下是在上一行）。\n\n可以把下面几句当成心里默念的小句子：\n\n- `yw` → “复制一个单词”；\n- `y$` → “复制到行尾”；\n- `yy` → “复制当前整行”；\n- `p` / `P` → “在后面/前面贴出来”。\n\n区别在于：这里你不再是“框选再复制”，而是用 motion 精确描述你要复制的范围。",
        "1": "## 示例：y+动作复制，p 粘贴\n\n用 `yw` 复制字符串字面量，删除占位，再按 `p` 把复制内容贴到新位置。",
        "2": {
          "tracks": {
            "0": "复制 + 粘贴：把一个名字用到别处"
          },
          "steps": {
            "0": "w：跳到 \"name\"。",
            "1": "w：跳到字符串 \"\"Ada\"\"。",
            "2": "y：对字符串开始 yank。",
            "3": "w：yw —— 复制字符串 \"\"Ada\"\"。",
            "4": "j：移动到 \"copy\" 行。",
            "5": "$：跳到行尾（分号之后）。",
            "6": "h：左移到空字符串 \"\"\"\"。",
            "7": "d：开始删除。",
            "8": "w：dw —— 删除空字符串字面量。",
            "9": "p：在光标后粘贴刚才复制的 \"\"Ada\"\"。"
          }
        },
        "3": {
          "keys": {
            "0": "复制（yank）操作符（y{motion} / yy）",
            "1": "在光标后/行下粘贴（p）",
            "2": "在光标前/行上粘贴（P）",
            "3": "复制整行（yy）"
          }
        },
        "4": {
          "goals": {
            "copy-name-into-copy": "让变量 \"copy\" 存和 \"name\" 一样的字符串，用一次 y{motion} + p 完成这个搬运。",
            "duplicate-log-line": "再写一行 std::cout 输出 \"copy\" 而不是 \"name\"，体验整行复制 + 小修改的工作流。"
          }
        }
      }
    },
    "count-repeat-undo": {
      "title": "次数、重复、撤销：一招用很多次",
      "shortDescription": "用数字前缀和 `.` 重复上一条修改，再配合 u / Ctrl-r 安全试错。",
      "content": {
        "0": "## 做一次，然后让 Vim 帮你重复\n\n很多重复性操作，其实可以抽象成：\n\n1. 先在某一处“做对一次”；\n2. 再让 Vim 帮你把这次修改复制到别的地方。\n\nVim 提供的两个加速器是：\n\n- **次数前缀**：命令前加数字多次执行：\n  - `3w` – 向前移动 3 个单词；\n  - `2dw` – 一次删除 2 个单词；\n- **点重复**（`.`）：\n  - 重复**上一次修改**（注意是修改，不是按键序列）。\n\n如果改多了或者改错了，也不用紧张：\n\n- **u** – 撤销上一次修改；\n- **Ctrl-r** – 重做刚刚撤销的那一次。\n\n推荐的心智模型是：\n\n1. 先耐心把“第一处”做好；\n2. 用 `.` 或次数前缀把这一处的修改扩散到其他位置；\n3. 有问题就 `u` 回去，或者 `Ctrl-r` 再试一遍。\n\n这样你就不再是在“重复劳动”，而是在编排“模板 + 重放”。",
        "1": "## 示例：次数 + 重复 + 撤销\n\n先把一个初始化改成 42，再用 `.` 把改动复制到下一行，失误就用 `u` / `Ctrl-r` 试错。",
        "2": {
          "tracks": {
            "0": "次数 + 点重复 + 撤销/重做"
          },
          "steps": {
            "0": "w：跳到 \"int\"。",
            "1": "w：跳到 \"value1\"。",
            "2": "w：跳到 \"0;\"。",
            "3": "c：在初始化位置开始修改。",
            "4": "w：cw —— 删除 \"0;\"。",
            "5": "输入 “4”。",
            "6": "输入 “2”，得到值 42;",
            "7": "输入 “;” 完成语句。",
            "8": "Escape：回到 Normal，一行修好了。",
            "9": "j：移动到 value2。",
            "10": ".：重复上次修改——再次设为 42。",
            "11": "j：移动到 value3。",
            "12": ".：再重复一次给 value3。",
            "13": "u：撤销——还原 value3 的修改。",
            "14": "Ctrl-r：重做——再次应用修改。"
          }
        },
        "3": {
          "keys": {
            "0": "命令前的次数前缀（数字 + 命令）",
            "1": "重复上一次修改（.）",
            "2": "撤销上一次修改（u）",
            "3": "重做上一次撤销（Ctrl-r）"
          }
        },
        "4": {
          "goals": {
            "all-values-42": "把 value1..value4 的初始值都改成 42，体验“先做好一处，再用 . 和次数扩散”的威力。"
          }
        }
      }
    },
    "operators-mini-review": {
      "title": "本章回顾：用操作符说 Vim 句子",
      "shortDescription": "把 d、c、y 和 motion、次数、重复组合起来，清理一小段程序。",
      "content": {
        "0": "## Vim 的句子：操作符 + 动作\n\n到这里为止，你已经认识了：\n\n- 各种动作 (motion)：**w, b, e, 0, ^, $** 等，用来描述“从这里走到哪里”；\n- 几个常用操作符 (operator)：**d**（删）、**c**（改）、**y**（复制）；\n- 辅助工具：次数前缀、**.** 重复、**u** 撤销、**Ctrl-r** 重做、**p/P** 粘贴。\n\nVim 鼓励你把这些组合成一句句“动作句”：\n\n> **动作句** = 操作符 + 动作\n> > `d` + `w` → 删除一个单词\n> > `c` + `$` → 改到行尾\n> > `y` + `0` → 复制到行首\n\n本章回顾会带你在一小段程序上做三件事：\n\n- 移除多余的调试行；\n- 把变量统一重命名；\n- 复制一行并做一点小改动；\n\n你可以用任意组合完成，只要最终结果正确即可。重点是练习“用 Vim 句子描述自己想做什么”。",
        "1": "## 示例：删改复制一气呵成\n\n用 **cw** 改名、**dd** 删调试行，再 **yy/p** 复制并改一行计算，整套动作像说话一样连贯。",
        "2": {
          "tracks": {
            "0": "操作符迷你流程：删一行 + 改名 + 复制改写"
          },
          "steps": {
            "0": "w：跳到 \"int\"。",
            "1": "w：跳到 \"count\"。",
            "2": "c：在变量名上开始修改。",
            "3": "w：cw —— 删除 \"count\" 并进入 Insert。",
            "4": "输入 “i”。",
            "5": "输入 “t”。",
            "6": "输入 “e”。",
            "7": "输入 “m”。",
            "8": "输入 “s”，得到 \"items\"。",
            "9": "Escape：回到 Normal，变量已改名。",
            "10": "j：移动到 debugValue 行。",
            "11": "d：dd 的第一下，准备删行。",
            "12": "d：第二下 d —— 整个调试行被删除。",
            "13": "k：回到 \"total = items * 2;\" 行。",
            "14": "y：yy 的第一下，复制整行。",
            "15": "y：第二下 y —— 行已复制。",
            "16": "p：在下方粘贴复制的行。",
            "17": "j：移动到新粘贴的行。",
            "18": "0：跳到行首。",
            "19": "w：跳到 \"total\"。",
            "20": "w：跳到 \"items\"。",
            "21": "w：跳到乘数 \"2;\"。",
            "22": "c：开始修改乘数。",
            "23": "w：cw —— 删除 \"2;\"。",
            "24": "输入 “3”。",
            "25": "输入 “;”，完成 \"3;\"。",
            "26": "Escape：回到 Normal，新行使用 3。"
          }
        },
        "3": {
          "keys": {
            "0": "删除操作符（d）",
            "1": "修改操作符（删除+插入：c）",
            "2": "复制操作符（y）",
            "3": "在光标后/行下粘贴（p）",
            "4": "在光标前/行上粘贴（P）",
            "5": "重复上一次修改（.）",
            "6": "撤销（u）",
            "7": "重做（Ctrl-r）"
          }
        },
        "4": {
          "goals": {
            "rename-count-to-items": "把 main 中的 \"count\" 都改成 \"items\"，让变量名更贴近含义。",
            "remove-debug-line": "删除声明 \"debugValue\" 的整行，把临时调试代码清理掉。",
            "add-multiplier-3": "在现有 \"total = items * 2;\" 下面再写一行 \"total = items * 3;\"，练习复制 + 修改的流程。"
          }
        }
      }
    },
    "find-char": {
      "title": "行内查找字符：f/F 与重复查找",
      "shortDescription": "当你知道要去的是“那个字符”时，用 f/F 和 ;/, 精准来回跳。",
      "content": {
        "0": "## 找字符，而不是猜要按几次 l\n\n有时候，你脑子里非常清楚要去的目标：\n\n- 字符串里的下一个逗号，\n- 这一行里的下一个右括号，\n- 某个分号。\n\n但如果只靠 `l` 一格一格挪，你就会变成“猜我要按几次 l 才能刚好停到那儿”，既慢又无聊。\n\n在 **Normal** 模式下，Vim 提供了一套“按字符找”的工具：\n\n- **f{char}** – 向前移动到本行下一个 `{char}`；\n- **F{char}** – 向后移动到本行上一个 `{char}`；\n- **;** – 按相同方向重复上一次 `f/F/t/T`；\n- **,** – 反向重复上一次 `f/F/t/T`。\n\n这一套在“逗号很多”“括号很多”的行里特别好用：你不再关心“要按几次”，只关心“我要去下一个逗号/括号/引号”。",
        "1": "## 示例：在逗号之间穿梭\n\n`f,` 落到第一个逗号，再用 **;** / **,** 前后跳转，不用再猜要按几次 `l`。",
        "2": {
          "0": "## 示例：在逗号之间跳转\n\n用一行包含多个逗号的 `std::cout` 输出练手：先用 `f,` 落到第一个逗号，再用 **;** / **,** 在逗号之间来回穿梭，不用再猜要按几次 `l`。"
        },
        "3": {
          "tracks": {
            "0": "用 f 和 ; , 找逗号"
          },
          "steps": {
            "0": "f：在本行开始一次向前字符查找。",
            "1": "\"f,\" 跳到字符串中的第一个逗号。",
            "2": "\";\" 重复上次 find，移动到下一个逗号。",
            "3": "\";\" 再次跳到第三个逗号。",
            "4": "\",\" 回到上一个逗号。"
          }
        },
        "4": {
          "keys": {
            "0": "寻找本行下一个逗号（f,）",
            "1": "寻找本行上一个逗号（F, 或配合 ,）",
            "2": "重复上次 f/F/t/T（同向：;）",
            "3": "重复上次 f/F/t/T（反向：,）"
          }
        },
        "5": {
          "goals": {
            "first-comma": "把光标移到行里的第一个逗号，感受 f 的“跳跃感”。",
            "last-comma": "把光标移到行里的最后一个逗号，熟悉用 ; / , 在匹配点之间来回穿梭。"
          }
        }
      }
    },
    "delete-with-find": {
      "title": "结合查找删除：df/dt 精准剪掉",
      "shortDescription": "用 d + f/t 针对行内某个字符之前/包含该字符的范围做删除。",
      "content": {
        "0": "## 删到某个字符，而不仅是“按词删”\n\n有了 **f** / **t** 之后，你已经可以在行内精确跳转到某个字符。\n\n下一步，就是把这个“查找能力”和删除操作符 **d** 组合起来：\n\n- **df{char}** – 从光标处删到下一个 `{char}`，**包含**该字符；\n- **dt{char}** – 从光标处删到下一个 `{char}` 之前，**不包含**该字符。\n\n常见用法：\n\n- `df;` – 删到分号，顺手把分号也一起删掉；\n- `dt)` – 删除括号里的内容，但右括号还留着。\n\n这类命令比“按词删”要细得多：你可以只剪掉参数列表的一部分、初始化的一段，而不伤及两侧的结构。",
        "1": "## 示例：删掉向量初始化\n\n光标在 `=` 上按 `df;`，把 `= {1, 2, 3, 4};` 整段剪掉，只留声明和分号。",
        "2": {
          "0": "## 示例：删掉向量初始化\n\n在一行向量初始化上，以等号为起点按 `df;`，直接把 `= {1, 2, 3, 4};` 整段剪掉，声明和分号都保留。"
        },
        "3": {
          "tracks": {
            "0": "用 d f{char} 删除一段"
          },
          "steps": {
            "0": "d：在等号处开始 delete 操作。",
            "1": "f：准备向前找字符。",
            "2": "\"df;\" 从 \"=\" 删到分号，移除整个初始化部分。"
          }
        },
        "4": {
          "keys": {
            "0": "从光标删到下一个分号（含分号：df;）",
            "1": "从光标删到右括号前（保留右括号：dt)）"
          }
        },
        "5": {
          "goals": {
            "clear-func-args": "删除 func(...) 里的参数，让调用变成 func()，保留括号结构。",
            "remove-debug-init": "删除 debug 行的 \"= 42;\" 初始值，保留变量名本身。"
          }
        }
      }
    },
    "change-with-find": {
      "title": "结合查找修改：cf/ct 精准改动",
      "shortDescription": "在行内用 c + f/t 重写一小段文本，例如括号里的参数或引号内的内容。",
      "content": {
        "0": "## 改到某个字符：先圈范围，再进入 Insert\n\n就像 `df/df` 可以删到某个字符，**c 操作符** 也能配合 find/till 来“改到某个字符”：\n\n- **cf{char}** – 从光标改到下一个 `{char}`，**包含**它；\n- **ct{char}** – 从光标改到下一个 `{char}` 之前，**不含**它。\n\n这两个命令都会：\n\n1. 删除这段范围；\n2. 自动进入 **Insert**，等待你输入替换内容。\n\n典型场景：\n\n- `ct\"` – 替换字符串内容到结束引号前，引号本身还在；\n- `ct)` – 重写括号内参数，右括号保留；\n- `cf)` – 包含右括号一起改写整段。",
        "1": "## 示例：重写名字字符串\n\n在 `\"Ada\"` 里用 `ct\"` 删到结束引号前，直接输入新名字，引号安然无恙。",
        "2": {
          "0": "## 示例：重写名字字符串\n\n在 `std::string name = \"Ada\";` 这一行，把光标放进字符串，用 `ct\"` 删到结束引号前，再直接输入新名字，引号原封不动。"
        },
        "3": {
          "tracks": {
            "0": "用 c t\" 修改字符串内容"
          },
          "steps": {
            "0": "c：在字符串内部开始 change 操作。",
            "1": "t：选择 till 动作（停在字符前）。",
            "2": "\"ct\\\"\"：删到结束引号前并进入 Insert。",
            "3": "输入 “B”。",
            "4": "输入 “o”。",
            "5": "输入 “b”，得到新值 \"Bob\"。",
            "6": "Escape：完成修改并返回 Normal。"
          }
        },
        "4": {
          "keys": {
            "0": "修改字符串内容直到结束引号前（ct\"）",
            "1": "修改到右括号前（不含右括号：ct)）",
            "2": "包含结束引号一起修改（cf\"）"
          }
        },
        "5": {
          "goals": {
            "change-greeting": "把 greeting 字符串改成 \"Hi\"，练习只改引号里的内容。",
            "change-name": "把 name 字符串改成 \"Ada Lovelace\"，体会 ct\" 在长文本上的用法。"
          }
        }
      }
    },
    "in-line-precision-review": {
      "title": "本章回顾：行内精准编辑",
      "shortDescription": "把 f/F/t/T 和 d/c 组合起来，对函数调用和字符串做精细“手术”。",
      "content": {
        "0": "## 行内精准手术：只动需要动的那一小块\n\n这一章结束时，你已经有了一整套“行内精准编辑”的工具：\n\n- **f/F** – 跳到本行的某个字符上；\n- **t/T** – 停在某个字符前/后；\n- **; / ,** – 重复上一次行内查找（向前/向后）；\n- **d{motion}** – 删除某个范围；\n- **c{motion}** – 删除某个范围并进入 Insert。\n\n它们可以一起完成很多精细任务，例如：\n\n- 从长函数调用里删掉第一个参数，保持其他参数结构不乱；\n- 重写字符串内部的内容，但保留两侧的引号；\n- 修剪或扩展初始化列表，只改中间那一段。\n\n这一课就是把这些工具串在一起，在一段小代码上做一次“行内手术实战”。",
        "1": "## 示例：在 add(10, 20, 30) 做微手术\n\n先 `dt,` 剪掉开头的 `10,`，再用 `ct)` 把剩余参数改成单个 `42`，快速又不破坏结构。",
        "2": {
          "0": "## 示例：在 add(10, 20, 30) 里做微手术\n\n围绕 `add(10, 20, 30)`，先用 **dt,** 删掉开头的 `10,`，再移动到末尾用 **ct)** 把剩余参数改成单个 `42`，结构不乱，动作很快。"
        },
        "3": {
          "tracks": {
            "0": "行内精准编辑"
          },
          "steps": {
            "0": "f：在调用内部前进。",
            "1": "\"f(\" 跳到左括号。",
            "2": "d：开始删除第一个参数。",
            "3": "t：使用 till（停在字符前）。",
            "4": "\"dt,\" 删掉 \"10,\"，保留后续参数的逗号。",
            "5": "f：再次向后移动到参数末尾。",
            "6": "\"f)\" 跳到右括号。",
            "7": "c：开始修改剩余参数。",
            "8": "t：\"ct)\" 会改到右括号前。",
            "9": "\")\"：删除当前参数并进入 Insert。",
            "10": "输入 “4”。",
            "11": "输入 “2”，改成单一参数 42。",
            "12": "Escape：完成修改，得到 add(42)。"
          }
        },
        "4": {
          "keys": {
            "0": "跳到本行下一个 \"(\"（f()）",
            "1": "停在下一个逗号前（t,）",
            "2": "删到（不含）下一个逗号（dt,）",
            "3": "改到（不含）右括号（ct)）",
            "4": "向前重复上次行内查找（;）",
            "5": "向后重复上次行内查找（,）"
          }
        },
        "5": {
          "goals": {
            "simplify-add-call": "把 add(...) 改成只传 42：add(42)，体验 dt,/ct) 的配合。",
            "update-message": "把 message 字符串改成 \"INFO: done\"（仅改引号内内容）。",
            "keep-structure": "确保 std::cout 这一行仍然打印 message 并带有 \"\\n\"，只改内容不破坏结构。"
          }
        }
      }
    },
    "textobjects-words": {
      "title": "单词文本对象：一把抓住一个词",
      "shortDescription": "用 iw/aw 把一个单词当作整体，让 d/c/y 不再需要猜到底删/改到哪。",
      "content": {
        "0": "## 文本对象：操作符 + i/a + 对象\n\n到目前为止，你已经会用“操作符 + 动作”的模式：\n\n- `d + w` → 删到下一个单词；\n- `c + $` → 改到行尾。\n\n**文本对象 (text object)** 在这个模式上再往前走了一步：\n\n> **操作符 + i/a + 对象**\n\n这里：\n\n- **i** 可以理解成“inner”，只取内部那一块；\n- **a** 可以理解成“a ... 含外壳”，带上外围空格或分隔符；\n- **w** 是 word（单词）。\n\n于是有了：\n\n- **diw** – 删除内部单词（只删这个词本身）；\n- **daw** – 删除单词以及它旁边那一格空格/标点；\n- **ciw** – 修改整个单词并进入 Insert；\n- **yiw** – 复制这个单词。\n\n相比“先量 motion 再操作”，文本对象更像是在说：\n\n> “我想对‘这个词’动手”，而不用再精确描述“从这里到那里”的路径。",
        "1": "## 示例：用 ciw 改名\n\n站在变量上按 `ciw` 清空整个词并输入新名字，无需估算 motion 范围。",
        "2": {
          "tracks": {
            "0": "用 ciw 重命名一个变量"
          },
          "steps": {
            "0": "c：开始修改当前单词。",
            "1": "i：选择内层单词对象。",
            "2": "w：ciw —— 删除整个单词并进入 Insert。",
            "3": "输入 “i”。",
            "4": "输入 “t”。",
            "5": "输入 “e”。",
            "6": "输入 “m”。",
            "7": "输入 “C”。",
            "8": "输入 “o”。",
            "9": "输入 “u”。",
            "10": "输入 “n”。",
            "11": "输入 “t”，完成 \"itemCount\"。",
            "12": "Escape：完成重命名，返回 Normal。"
          }
        },
        "3": {
          "keys": {
            "0": "删除光标处的内部单词（diw）",
            "1": "删除单词及周围空格/标点（daw）",
            "2": "修改内部单词并进入 Insert（ciw）",
            "3": "复制内部单词（yiw）"
          }
        },
        "4": {
          "goals": {
            "rename-oldValue": "把所有 \"oldValue\" 改为 \"newValue\"，体会 iw 在“整词改名”上的爽感。",
            "rename-oldCount": "把所有 \"oldCount\" 改为 \"newCount\"，不再手动用 w/b/e 慢慢圈选范围。"
          }
        }
      }
    },
    "textobjects-paragraphs": {
      "title": "段落文本对象：一口气改一段",
      "shortDescription": "把连续的注释/说明当作“段落”，用 ip/ap 整体删除、复制或重写。",
      "content": {
        "0": "## 段落作为文本对象：不用精确选行号\n\n在 Vim 里，一个 **段落 (paragraph)** 是：\n\n> 一块连续的非空行，由空行与其它内容隔开。\n\n它很适合表示：\n\n- 多行注释说明；\n- 小的文档片段；\n- 中间夹着一段解释性文字的代码区域。\n\n对应的文本对象是：\n\n- **ip** – inner paragraph：只包含段落本身；\n- **ap** – a paragraph：段落本身 + 外面多带一个空行。\n\n可与操作符组合：\n\n- **dip** – 删除内段落；\n- **yip** – 复制这个段落；\n- **cip** – 删掉这一整段，然后进入 Insert 重写内容；\n- **dap** – 删除段落并带上一个空行。\n\n当你只想“整块处理这一段说明”，不想先一行行数行号、选范围，ip/ap 会省很多心。",
        "1": "## 示例：dip 直接抹掉注释块\n\n光标在注释段里，`d i p` 一步删除整段说明，不用对齐行号。",
        "2": {
          "tracks": {
            "0": "用 dip 删除整段注释"
          },
          "steps": {
            "0": "d：在注释块上开始删除操作。",
            "1": "i：选择内部对象。",
            "2": "p：dip —— 一次删除整个注释段落。"
          }
        },
        "3": {
          "keys": {
            "0": "删除光标周围的内段落（dip）",
            "1": "复制段落（yip）",
            "2": "修改段落并进入 Insert（cip）",
            "3": "删除段落并带上一个空行（dap）"
          }
        },
        "4": {
          "goals": {
            "remove-note-paragraph": "删除 NOTE 段落（保留 Description 段），体验段落级别的“整体擦除”。",
            "duplicate-description": "在 std::string name 上方再复制一份 Description 段落，好像在代码里加一份“翻译版说明”。"
          }
        }
      }
    },
    "textobjects-brackets": {
      "title": "括号文本对象：处理括号内容",
      "shortDescription": "用 i(/a(、i{/a{、i[/a[ 把括号里的内容视作一个整体来删/改/复制。",
      "content": {
        "0": "## 括号类文本对象：函数参数、初始化、下标访问\n\n你经常会遇到这些场景：\n\n- 函数参数列表：`add(10, 20, 30)`；\n- 初始化列表：`values{1, 2, 3, 4}`；\n- 数组或向量访问：`values[0]`。\n\n这些地方都有“括号包起的一坨东西”。用 motion 一步步 e / f / t 去量范围固然可以，但太啰嗦。\n\n括号类文本对象帮你直接说：\n\n- **i(** / **a(** – 括号内 / 括号连同周围；\n- **i{** / **a{** – 花括号内 / 整个花括号；\n- **i[** / **a[** – 方括号内 / 连同方括号。\n\n配合操作符：\n\n- **di(** – 删除 `(...)` 内的内容，括号还在；\n- **ci{** – 改写 `{...}` 内内容，然后输入新内容；\n- **yi(** – 复制 `(...)` 内的内容。\n\n从此你可以说：\n\n> “把这个括号里面的东西全删了/换掉”，而不必手动算 motion。",
        "1": "## 示例：di( 清空参数\n\n进入函数调用内部，用 `di(` 一次清掉括号里的参数，括号本身不动。",
        "2": {
          "tracks": {
            "0": "用 di( 清空参数"
          },
          "steps": {
            "0": "f：查找 \"(\"。",
            "1": "\"f(\" 跳到左括号。",
            "2": "l：移动到括号内部。",
            "3": "d：开始删除操作符。",
            "4": "i：选择内层括号对象。",
            "5": "(：di( —— 删除所有参数，仅留 add()。"
          }
        },
        "3": {
          "keys": {
            "0": "删除 (...) 内部，保留括号（di()）",
            "1": "删除 {...} 内部，保留花括号（di{）",
            "2": "修改 (...) 内并输入新参数（ci()）",
            "3": "复制初始化列表 {...} 内内容（yi{）"
          }
        },
        "4": {
          "goals": {
            "clear-initializer": "把初始化列表改为空：values{};，只保留变量和类型定义。",
            "clear-add-arguments": "把 add(...) 改成 add(); 去掉所有参数但保留调用结构。"
          }
        }
      }
    },
    "textobjects-quotes": {
      "title": "引号文本对象：一把抓住字符串",
      "shortDescription": "用 i\"/a\" 等文本对象，不用数字符就能改写字符串内部。",
      "content": {
        "0": "## 引号文本对象：不用再数字符串里的字符\n\n字符串在代码里无处不在，但逐个字符数位置是一件很痛苦的事情。\n\n针对各种引号，Vim 提供了对应的文本对象：\n\n- **i\"** / **a\"** – 双引号内 / 含引号；\n- **i'** / **a'** – 单引号内 / 含引号；\n- **i`** / **a`** – 反引号字符串内 / 含引号（在其他语言里很常见）。\n\n配合操作符，你可以很自然地说：\n\n- **ci\"** – 改写字符串内容，但保留引号；\n- **di\"** – 删掉字符串内容，保留引号；\n- **yi\"** – 复制字符串内容。\n\n只要光标在字符串内部或旁边，你就可以用 i\"/a\" 把“里面那一坨”当整块看待，而不必再数这是第几个字符。",
        "1": "## 示例：ci\" 改写字符串\n\n跳进字符串，用 `ci\"` 清空内容并输入更短的消息，省去数字符。",
        "2": {
          "tracks": {
            "0": "用 ci\" 修改字符串"
          },
          "steps": {
            "0": "f：寻找开头的双引号。",
            "1": "目标双引号：跳到字符串开始。",
            "2": "l：移动到字符串内部。",
            "3": "c：开始修改。",
            "4": "i：选择内层双引号对象。",
            "5": "\"：ci\" —— 删除 \"Hello, world\" 并进入 Insert。",
            "6": "输入 “H”。",
            "7": "输入 “i”。",
            "8": "输入 “!” 组成 \"Hi!\"。",
            "9": "Escape：结束修改，返回 Normal。"
          }
        },
        "3": {
          "keys": {
            "0": "修改双引号字符串内部（ci\"）",
            "1": "删除双引号字符串内部（di\"）",
            "2": "复制双引号字符串内部（yi\"）"
          }
        },
        "4": {
          "goals": {
            "change-level-to-debug": "把 level 字符串改成 \"DEBUG\"，感受 ci\" 在短字符串上的用法。",
            "change-message-to-shutdown": "把 message 字符串改成 \"Shutting down\"，练习在较长文本里精确改写。"
          }
        }
      }
    },
    "textobjects-mega-review": {
      "title": "文本对象总复盘：词括号段落",
      "shortDescription": "把 iw/aw、ip/ap、i(/i{/i[、i\" 等文本对象和 d/c/y 组合起来，重构一小段 C++。",
      "content": {
        "0": "## 文本对象全景：从“走路径”升级成“操作结构”\n\n走到这一章，你已经掌握了好几类文本对象：\n\n- **iw/aw** – 单词级别；\n- **ip/ap** – 段落级别；\n- **i(/a(**、**i{/a{**、**i[/a[** – 括号包含的部分；\n- **i\"/a\"** – 字符串内部。\n\n配合操作符，它们组成了一句句“Vim 语句”：\n\n- **ciw** – 修改这个词；\n- **di(** – 删除括号内内容；\n- **ci\"** – 改写这个字符串；\n- **dip** – 删除整个注释段落。\n\n和只用 motion 相比，文本对象更“结构化”：你不再关心“从这里走几步到那”，而是直接说“对这一整块做事”。\n\n这一课会把几类文本对象串起来，在一段小程序上做一次真正的重构练习。",
        "1": "## 示例：ci\" 接 di{ 一气呵成\n\n先用 `ci\"` 改字符串，再 `di{` 清空 if 块，展示文本对象可以连着用。",
        "2": {
          "tracks": {
            "0": "组合 ci\" 与 di{：改错信息 + 清空 if 块"
          },
          "steps": {
            "0": "f：找到 logError 调用里的双引号。",
            "1": "目标双引号：跳到字符串开头。",
            "2": "l：进入字符串内部。",
            "3": "c：开始修改字符串内容。",
            "4": "i：选择内层双引号对象。",
            "5": "\"：ci\" —— 删掉 \"Name is empty\" 并进入 Insert。",
            "6": "输入 “I”。",
            "7": "输入 “n”。",
            "8": "输入 “v”。",
            "9": "输入 “a”。",
            "10": "输入 “l”。",
            "11": "输入 “i”。",
            "12": "输入 “d”，开始 \"Invalid name\"。",
            "13": "输入空格。",
            "14": "输入 “n”。",
            "15": "输入 “a”。",
            "16": "输入 “m”。",
            "17": "输入 “e”，完成 \"Invalid name\"。",
            "18": "Escape：完成字符串修改。",
            "19": "k：上移到带左花括号的 if 行。",
            "20": "f：查找左花括号 \"{\"。",
            "21": "{：跳到花括号。",
            "22": "j：进入块内部。",
            "23": "d：开始删除操作符。",
            "24": "i：选择内层花括号对象。",
            "25": "{：\"di{\" —— 删除 if 块内部全部内容。"
          }
        },
        "3": {
          "keys": {
            "0": "修改内部单词（ciw）",
            "1": "修改字符串内部（ci\"）",
            "2": "删除括号内部（di()）",
            "3": "删除花括号内部（di{）",
            "4": "删除内段落（dip）"
          }
        },
        "4": {
          "goals": {
            "rename-userName-to-name": "把所有 \"userName\" 改成 \"name\"，用 ciw/iw 等组合统一改名。",
            "change-greeting-to-hi": "把 greeting 字符串改成 \"Hi\"，练习在字符串内部改写常量。",
            "update-error-call": "在 if 分支里将 logMessage 调用改为 \"FATAL\" 和 \"name is empty\"，综合运用文本对象和搜索。"
          }
        }
      }
    },
    "search-basic": {
      "title": "搜索与重复：/ n N * #",
      "shortDescription": "用 / 和 * 在所有匹配间跳转，再用 n/N 在结果之间来回穿梭。",
      "content": {
        "0": "## 跨缓冲区搜索：不要一行行往下翻了\n\n当文件变长之后，靠滚轮或 j/k 一行一行往下翻，很快会让你怀疑人生。\n\nVim 提供的“全局视角”就是搜索：\n\n- **/pattern** – 向前（往文件后面）搜索 `pattern`；\n- **?pattern** – 向后（往文件前面）搜索；\n- **n** – 跳到下一个匹配；\n- **N** – 跳到上一个匹配。\n\n除此之外，你还能直接拿“光标下的单词”当搜索关键词：\n\n- *** – 向前搜索光标下的单词；\n- **#** – 向后搜索光标下的单词。\n\n这意味著：你只要把光标放在 `TODO`、`value`、某个变量名上，一按 `*`，就能在整个文件里一站一站地逛所有同名位置。",
        "1": "## 示例：在所有 “Ada” 间穿梭\n\n把光标放到第一个 “Ada”，按 `*` 搜索，再用 **n/N** 在匹配间来回跳，就像坐地铁刷站。",
        "2": {
          "0": "## 示例：在所有 “Ada” 间跳转\n\n一行行找太慢？从第一个 \"Ada\" 开始按 `*` 搜索，再用 **n / N** 在各个匹配间穿梭，体验“全局跳站”而不是滚轮大法。"
        },
        "3": {
          "tracks": {
            "0": "用 * 和 n/N 搜索并跳转"
          },
          "steps": {
            "0": "*：搜索光标下的 \"Ada\" 并跳到下一个匹配。",
            "1": "n：跳到下一个 \"Ada\"。",
            "2": "n：再跳一次，走完当前文件中的所有 \"Ada\"。",
            "3": "N：返回上一个匹配。",
            "4": "N：回到第一个 \"Ada\"。"
          }
        },
        "4": {
          "keys": {
            "0": "向前搜索模式（/pattern）",
            "1": "跳到下一个匹配（n）",
            "2": "跳到上一个匹配（N）",
            "3": "向前搜索光标下单词（*）",
            "4": "向后搜索光标下单词（#）"
          }
        },
        "5": {
          "goals": {
            "replace-todo-with-done": "把所有 \"TODO\" 都改成 \"DONE\"，让你体验“找所有匹配 + 一处处修改”的流程。",
            "cursor-on-start-server-comment": "把光标放到包含 \"start server\" 的注释行上，用搜索快速定位这类关键说明。"
          }
        }
      }
    },
    "search-with-operators": {
      "title": "搜索 + 操作符：快速重构",
      "shortDescription": "先用 / 或 * 找到所有匹配，再用 ciw / ci\" + 点重复批量修改。",
      "content": {
        "0": "## 先搜，再操作：把“重复编辑”变成“一次示范，多次重放”\n\n到目前为止，你已经学过：\n\n- 用 **/**、**?** 或 *** 在整个文件中搜索；\n- 用操作符 + 动作 / 文本对象（比如 `ciw`、`ci\"`）做局部修改；\n- 用 **n** / **N** 在匹配之间跳转；\n- 用 **.** 重复上一条修改。\n\n把它们按顺序组合起来，就变成了一个高效的套路：\n\n1. 用 **/pattern** 或 *** 落在第一个匹配位置；\n2. 用一次 `ciw` / `ci\"` 做好“示范修改”；\n3. 用 **n** 跳到下一个匹配；\n4. 用 **.** 在新位置重复刚才那次修改。\n\n这就是 Vim 常见的“搜索 + 操作符 + 重放”工作流：一次正确的修改，换来全局多处的快速重构。",
        "1": "## 示例：把 DEBUG 改成 INFO\n\n用 `/DEBUG` 落到第一个位置，按 **ci\"** 改成 \"INFO\"，再到下一个匹配用 `.` 复刻同样的修改。",
        "2": {
          "0": "## 示例：把 DEBUG 改成 INFO\n\n两个 \"DEBUG\"，一套动作：用 `/DEBUG` 先落到第一个，按 **ci\"** 改成 \"INFO\"，移动到第二个后按 `.` 直接重播这次修改。"
        },
        "3": {
          "tracks": {
            "0": "ci\" + 点重复：从 DEBUG 到 INFO"
          },
          "steps": {
            "0": "c：开始修改字符串内容。",
            "1": "i：选择内层双引号对象。",
            "2": "\"：ci\" 删除 \"DEBUG\" 并进入 Insert。",
            "3": "输入 “I”。",
            "4": "输入 “N”。",
            "5": "输入 “F”。",
            "6": "输入 “O”。",
            "7": "Escape：结束编辑，字符串变成 \"INFO\"。",
            "8": "j：移动到第二个 \"DEBUG\"。",
            "9": ".：重复上次修改，也改成 \"INFO\"。"
          }
        },
        "4": {
          "keys": {
            "0": "搜索模式（/pattern 或 *）",
            "1": "跳到下一个匹配（n）",
            "2": "搜索光标下单词（*）",
            "3": "修改字符串内部并进入 Insert（ci\"）",
            "4": "重复上一次修改（.）"
          }
        },
        "5": {
          "goals": {
            "rename-logdebug-to-loginfo": "把函数及调用从 logDebug 改名为 logInfo，用搜索 + ciw/点重复完成重命名。",
            "change-debug-prefix-to-info": "把日志前缀从 \"[DEBUG]\" 改成 \"[INFO]\"，体验字符串内部重写的批量应用。"
          }
        }
      }
    },
    "realworld-cleanup-1": {
      "title": "真实清理：给 main 函数做减法",
      "shortDescription": "用搜索、操作符和重复清理临时调试代码和不再需要的噪音。",
      "content": {
        "0": "## 用搜索清理嘈杂代码：先找脏点，再统一抹掉\n\n在真实项目里，你经常需要：\n\n- 移除临时的调试块；\n- 修正到处 copy-paste 的错误常量；\n- 更新日志信息或状态提示。\n\n如果靠滚轮加方向键一点点翻，你会很快厌倦这一切。\n\n更好的做法是：\n\n- 用 **/pattern** 直接跳到每个“脏点”；\n- 在某一个匹配处用 **d** 或 **c**（配合动作/文本对象）做一次“示范修改”；\n- 用 **.** 把同样的修改应用到后续匹配上；\n- 出错就用 **u** / **Ctrl-r** 回退或重做。\n\n这节课会在一个小小的 main 函数上演示这种“搜索 + 操作符 + 重复”的清理流程。",
        "1": "## 示例：删掉一行调试注释\n\n先 `/DEBUG` 定位，再按 `dd` 一次删掉整行，不必慢慢挪光标。",
        "2": {
          "0": "## 示例：删掉一行调试注释\n\n小小的 main 里，先用 `/DEBUG` 定位，再按 `dd` 一次删掉整行注释，不用慢慢挪光标。"
        },
        "3": {
          "tracks": {
            "0": "搜索并删除调试行"
          },
          "steps": {
            "0": "/：开始向前搜索。",
            "1": "输入 “D”。",
            "2": "输入 “E”。",
            "3": "输入 “B”。",
            "4": "输入 “U”。",
            "5": "输入 “G”。",
            "6": "Enter：跳到 \"DEBUG\" 匹配。",
            "7": "d：dd 的第一下，准备删行。",
            "8": "d：第二下 d —— 调试注释行删除。"
          }
        },
        "4": {
          "keys": {
            "0": "向前搜索模式（/pattern）",
            "1": "跳到下一个匹配（n）",
            "2": "删除当前行（dd）",
            "3": "重复上次修改（.）",
            "4": "撤销上次修改（u）",
            "5": "重做上次撤销（Ctrl-r）"
          }
        },
        "5": {
          "goals": {
            "remove-debug-block": "删除仅调试用的 if (debug) 块及其日志，让生产代码更干净。",
            "change-port-to-80": "把端口初始化改为 80（原为 8080），配合搜索快速找到配置位置。",
            "improve-info-message": "把 info 信息改成 \"[INFO] server ready\"，顺便感受一下“先搜再改”的节奏。"
          }
        }
      }
    },
    "speedrun-challenge": {
      "title": "速通练习：小任务，快操作",
      "shortDescription": "在同一小片代码上，用搜索、文本对象和点重复打磨手速与稳定性。",
      "content": {
        "0": "## 为肌肉记忆设计的速练场\n\n这一节不再讲新概念，而是给你一小块“训练场地”。\n\n你已经会：\n\n- 按 word/WORD 移动（w/b/e，W/B/E）；\n- 用 **/**、**n**、*** 搜索；\n- 用操作符和文本对象编辑；\n- 用 **.** 把刚才那一次修改复制到别的地方。\n\n现在我们在同一段小代码上设计了几个简单、但可重复的任务，请尽量做到：\n\n- 手速逐渐提升；\n- 失误时知道用 u / Ctrl-r 自救；\n- 让“搜索 + 修改 + 重复”的节奏变成肌肉记忆。",
        "1": "## 示例：重命名重复变量\n\n`*` 串起所有 `value`，第一次 **ciw** 改名，后续用 **n** + `.` 复刻，动作连起来像刷 combo。",
        "2": {
          "0": "## 示例：重命名重复变量\n\n在一段到处都是 `value` 的代码里：先用 `*` 把所有位置串起来，第一次用 **ciw** 改名，后面的匹配用 **n** + `.` 直接复刻这次改动。"
        },
        "3": {
          "tracks": {
            "0": "搜索 + ciw + 点重复"
          },
          "steps": {
            "0": "*：搜索 \"value\" 并跳到下一个匹配。",
            "1": "c：开始修改当前单词。",
            "2": "i：选择内层单词。",
            "3": "w：ciw —— 删除单词并进入 Insert。",
            "4": "输入 “x” 作为新短名。",
            "5": "Escape：完成这一处修改。",
            "6": "n：跳到下一个 \"value\"。",
            "7": ".：重复修改，把下一个也改为 \"x\"。"
          }
        },
        "4": {
          "keys": {
            "0": "搜索光标下单词（*）",
            "1": "修改内层单词（ciw）",
            "2": "跳到下一个匹配（n）",
            "3": "重复上一次修改（.）"
          }
        },
        "5": {
          "goals": {
            "rename-value-to-count": "把片段中的 \"value\" 都改成 \"count\"，模拟一次小范围变量重命名。",
            "change-initializer-to-42": "把初始化改为 count = 42，巩固数字修改 + 重放的套路。",
            "remove-todo-comment": "移除声明行的 TODO 注释，练习在搜索 + 编辑的节奏里穿插简单删除。"
          }
        }
      }
    }
  }
}